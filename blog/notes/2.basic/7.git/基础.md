# 	基础

>`git`（读音为/gɪt/）是一个开源的`分布式版本控制软件`
>
>可以有效、高速地进行从很小到非常大的项目版本管理。 也是Linux之父Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件
>
>具体来说，就是用来管理代码项目的软件
>
>作为一名软件开发者，肯定会有很多代码项目，这些项目就可以使用`git`来提交至基于`git`的代码存储平台如`github`、`gitee`、`gitlab`等等，且可以管理它们的不同版本，还可以去克隆别的开发者的开源项目，拉取他们的代码学习，而且`git`命令适用于所有基于`git`的代码存储平台
>
>综上，`git`应是一名软件开发者的必备技能

## 安装

windows下安装非常方便，只需[官网](https://git-scm.com/downloads)下载安装程序，按指引安装即可

安装完成后，打开cmd终端输入

```sh
git -v
git --version
```

出现相应git版本，说明安装成功

可以使用线上的练习网站，[gitlearn](https://learngitbranching.js.org/?locale=zh_CN), 这需要已经对git命令有了基础的了解，进行实战练习

## 查看修改本地用户名和邮箱

```sh
# 查看
git config user.name
git config user.email

# 修改
git config --global user.name "git-userName"
git config --global user.email "git-email"
```

## 查看状态

显示文件修改情况，是否添加到本地仓库了

```sh
git status 
```

## .gitignore

为 npm 包添加.gitignore，文件内容加入，代码提交至仓库时就会跳过.gitignore 中的内容，如以下代码就会跳过 node_modules

```sh
node_modules
```

如果不想提交.gitignore，可以在.git/info/exclude 中加入以下代码排除它自身

```sh
.gitignore
```

## commit

git log查看commit的哈希，然后回退到相应commi

```sh
git reset --hard f36801544670e00b2f59a28e19017d2786c4085e
```

修改才提交的commit

```sh
git commit --amend
```

## git log

`git log`命令用于显示提交日志信息即git commit信息

默认显示最新的20条，按住上下键查看的commit信息列表

按q退出log模式

```sh
# 打印
git log
# 打印在一行
git log --oneline
```

### 定制git log格式

个人使用的自定义log命令

```sh
git log --pretty=format:"* %Cblue%h%Creset - (%Cgreen%ar%Creset) %s -- %Cblue%an"
```

其它一些自定义log命令参考

```sh
git log --pretty=format:"%an, %ar : %s"
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
git log --pretty=format:"  %an : %Cgreen%ar , %Cblue%s% "
```

| 选项    | 说明                                       |
| ------- | ------------------------------------------ |
| %H      | 提交对象（commit）的完整哈希字串           |
| %h      | 提交对象的简短哈希字串                     |
| %T      | 树对象（tree）的完整哈希字串               |
| %t      | 树对象的简短哈希字串                       |
| %P      | 父对象（parent）的完整哈希字串             |
| %p      | 父对象的简短哈希字串                       |
| %an     | 作者（author）的名字                       |
| %ae     | 作者的电子邮件地址                         |
| %ad     | 作者修订日期（可以用 -date= 选项定制格式） |
| %ar     | 作者修订日期，按多久以前的方式显示         |
| %cn     | 提交者(committer)的名字                    |
| %ce     | 提交者的电子邮件地址                       |
| %cd     | 提交日期                                   |
| %cr     | 提交日期，按多久以前的方式显示             |
| %s      | 提交说明                                   |
| %Creset | 表示重置颜色，不受之前的颜色               |
| %Cred   | 红色                                       |
| %Cgreen | 绿色                                       |
| %Cblue  | 蓝色                                       |

 作者（author）和 提交者（committer）区别 : 作者指的是实际作出修改的人，提交者指的是最后将此修改提交到仓库的人

### 命令别名

自定义的命令无疑是很长的，基本上只能复制粘贴地进行使用，所以使用命令别名来更方便地使用

如以下命令设置别名为git lg ，之后直接输入git lg即可

```sh
git config --global alias.lg "log --pretty=format:'* %Cblue%h%Creset - (%Cgreen%ar%Creset) %s -- %Cblue%an'"
```

## 查看与删除代理

```sh
# 查看全局http代理
git config --global http.proxy
# 查看全局https代理
git config --global https.proxy
# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
```

## shell脚本一键提交代码

在本地项目文件夹目录中，新建txt文件，加入以下内容，更改后缀为bat，点击即可运行，会将当前项目直接提交

```sh
#! /bin/bash
time=$(date "+%Y-%m-%d %H:%M:%S")
git add .
git commit -m ":memo:撰写文档 $time"
git push
```

## 回滚

一定要备份，一定要备份，一定要备份，比如手动复制一份src文件夹文件放在别处

```sh
git reset ：回滚到某次提交
git reset --soft：此次提交之后的修改会被退回到暂存区
git reset --hard：此次提交之后的修改不做任何保留，git status 查看工作区是没有记录的
```

相信大家都做过这个操作，就是本地做了修改后，不想提交，想恢复如初

```sh
git reset HEAD
```

这样的话，我们就可以回到开始了。但这个操作好像仅限于在master之类的分支上，如果是在
一个新的远程分支，就会出现：
Unstaged changes after reset

解决的办法如下2种办法：

```sh
git add .
git reset --hard
```

```sh
git stash
git stash drops
```

出现这种现象的原因好像是因为在新分支上，repos没有感知不到这个阶段的改变，你要用 add 或 stash, 让其知晓，才能做想要的回滚。

##  Fast-forward

默认情况下直接使用 `git merge` 命令，没有附加任何选项命令的话，那么应该是交给 git 来判断使用哪种 merge 模式，实际上 git 默认执行的指令是 `git merge -ff` 指令（默认值）

### 什么是 `Fast-forward`

git merge会自动执行了 `Fast-forward` 操作
`Fast-forward` 是指 Master 合并 Feature 时候发现 Master 当前节点一直和 Feature 的根节点相同，没有发生改变，那么 Master 快速移动头指针到 Feature 的位置，所以 **Fast-forward 并不会发生真正的合并**，只是通过移动指针造成合并的假象，这也体现 git 设计的巧妙之处。

先简单介绍一下 `git merge` 的三个合并参数模式：

- -ff 自动合并模式：当合并的分支为当前分支的后代的，那么会自动执行 `--ff (Fast-forward)` 模式，如果不匹配则执行 `--no-ff（non-Fast-forward）` 合并模式
- --no-ff 非 Fast-forward 模式：在任何情况下都会创建新的 commit 进行多方合并（及时被合并的分支为自己的直接后代）
- --ff-onlu Fast-forward 模式：只会按照 `Fast-forward` 模式进行合并，如果不符合条件（并非当前分支的直接后代），则会拒绝合并请求并且推出

### 选择

三种 merge 模式没有好坏和优劣之分，只有根据团队的需求和实际情况选择合适的合并模式才是最优解，那么应该怎么选择呢？ 给出以下推荐：

- 如果你是小型团队，并且追求干净线性 git 历史记录，那么我推荐使用 `git merge --ff-only` 方式保持主线模式开发是一种不错的选择
- 如果你团队不大不小，并且也不追求线性的 git 历史记录，要体现相对真实的 merge 记录，那么默认的 `git --ff` 比较合适
- 如果你是大型团队，并且要严格监控每个功能分支的合并情况，那么使用 `--no-ff` 禁用 `Fast-forward` 是一个不错的选择

## git rebase/变基

变基时有六个命令可用：

### edit

> 如果您选择edit提交，则将有机会修改提交，这意味着您可以完全添加或更改提交。您还可以进行更多提交，然后再继续进行变基。这使您可以将大型提交拆分为较小的提交，或者删除在提交中所做的错误更改

### exec

> 这使您可以对提交运行任意的Shell命令

### pick/更改提交顺序

> pick只是意味着包括提交。重新进行命令时，重新安排pick命令的顺序会更改提交的顺序。如果选择不包括提交，则应删除整行

示例操作，更换倒数第一次和倒数第二次的提交记录顺序

1. git rebase -i HEAD~2  告诉git 我要改变倒数第2次后的提交，会打开vim编辑器
2. 把 第一行 和 第二行 交换顺序，移动到第一行 按`dd`，本行就被剪切，第二行就变成了第一行，接着按 `p`刚刚剪切的就成了第二行，快速交换顺序
3. 接着 `Esc`,`:wq` 保存退出

### reword/更改提交信息

> 该reword命令与相似pick，但是使用后，重新设置过程将暂停并为您提供更改提交消息的机会。提交所做的任何更改均不受影响

示例操作，更改第一行的提交信息

1. git rebase -i HEAD~2
2. `i`进入插入模式，`Del`删除第一行的`pick`，改为`r`
3. 接着 `Esc`,`:wq` 保存退出
4. 就可以修改第一行了的commit了，`i`进入插入模式，更改第一行commit
5. 接着 `Esc`,`:wq` 保存退出

### squash/合并提交

> 该命令使您可以将两个或多个提交合并为一个提交。提交被压缩到其上方的提交中。Git使您有机会编写描述这两个更改的新提交消息

示例操作，合并第一行和第二行的提交

- git rebase - i HEAD~2
- `i`进入插入模式，`Del`删除第二行的`pick`，改为`r`
- 接着 `Esc`,`:wq` 保存退出
- 就可以修改输入后的commit了，输入commit
- 接着 `Esc`,`:wq` 保存退出

### fixup/合并提交

> 类似`squash`，也是用于合并提交，但要合并的提交会丢弃其commit消息。提交仅合并到其上方的提交中，并且使用较早提交的commit消息来描述这两个更改

示例操作，合并第一行和第二行的提交

- git rebase -i HEAD~2  
- `i`进入插入模式，`Del`删除第二行的`pick`，改为`f`
- 接着 `Esc`,`:wq` 保存退出
- `git log`打印会发现只有最新一次和倒数第二次的commit合并了，commit消息是倒数第二次的消息

###  git rebase --abort

控制台出现：fatal: It seems that there is already a rebase-merge directory, and I wonder if you are in the middle of another rebase.  If that is the case, please try

使用该命令解决该问题，放弃之前的变基操作

### 用法一

场景：一个开发任务，需要三天完成，每天都提交一部分代码，直到第三天完成整个任务，这时候我们想合并第一天到第三天的commit提交记录，因为这才是一个完整的开发任务，从而使记录更简洁更易于他人

```sh
# 指定一个commit的hash代码，合并当前到该hash之间的所有提交记录
git rebase -i commit的hash代码
```

