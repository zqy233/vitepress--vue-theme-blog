# 	基础

>`git`（读音为/gɪt/）是一个开源的`分布式版本控制软件`
>
>可以有效、高速地进行从很小到非常大的项目版本管理。 也是Linux之父Linus Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件
>
>具体来说，就是用来管理代码项目的软件
>
>作为一名软件开发者，肯定会有很多代码项目，这些项目就可以使用`git`来提交至基于`git`的代码存储平台如`github`、`gitee`、`gitlab`等等，且可以管理它们的不同版本，还可以去克隆别的开发者的开源项目，拉取他们的代码学习，而且`git`命令适用于所有基于`git`的代码存储平台
>
>综上，`git`应是一名软件开发者的必备技能

## 安装

windows下安装非常方便，只需[官网](https://git-scm.com/downloads)下载安装程序，按指引安装即可

安装完成后，打开cmd终端输入

```sh
git -v
git --version
```

出现相应git版本，说明安装成功

可以使用线上的练习网站，[gitlearn](https://learngitbranching.js.org/?locale=zh_CN), 这需要已经对git命令有了基础的了解，进行实战练习

## 查看修改本地用户名和邮箱

```sh
# 查看
git config user.name
git config user.email

# 修改
git config --global user.name "git-userName"
git config --global user.email "git-email"
```

## 查看状态

显示文件修改情况，是否添加到本地仓库了

```sh
git status 
```

## .gitignore

为 npm 包添加.gitignore，文件内容加入，代码提交至仓库时就会跳过.gitignore 中的内容，如以下代码就会跳过 node_modules

```sh
node_modules
```

如果不想提交.gitignore，可以在.git/info/exclude 中加入以下代码排除它自身

```sh
.gitignore
```

## commit

git log查看commit的哈希，然后回退到相应commi

```sh
git reset --hard f36801544670e00b2f59a28e19017d2786c4085e
```

修改才提交的commit

```sh
git commit --amend
```

## git log

`git log`命令用于显示提交日志信息即git commit信息

默认显示最新的20条，按住上下键查看的commit信息列表

按q退出log模式

```sh
# 打印
git log
# 打印在一行
git log --oneline
```

### 定制git log格式

个人使用的自定义log命令

```sh
git log --pretty=format:"* %Cblue%h%Creset - (%Cgreen%ar%Creset) %s -- %Cblue%an"
```

其它一些自定义log命令参考

```sh
git log --pretty=format:"%an, %ar : %s"
git log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit
git log --pretty=format:"  %an : %Cgreen%ar , %Cblue%s% "
```

| 选项    | 说明                                       |
| ------- | ------------------------------------------ |
| %H      | 提交对象（commit）的完整哈希字串           |
| %h      | 提交对象的简短哈希字串                     |
| %T      | 树对象（tree）的完整哈希字串               |
| %t      | 树对象的简短哈希字串                       |
| %P      | 父对象（parent）的完整哈希字串             |
| %p      | 父对象的简短哈希字串                       |
| %an     | 作者（author）的名字                       |
| %ae     | 作者的电子邮件地址                         |
| %ad     | 作者修订日期（可以用 -date= 选项定制格式） |
| %ar     | 作者修订日期，按多久以前的方式显示         |
| %cn     | 提交者(committer)的名字                    |
| %ce     | 提交者的电子邮件地址                       |
| %cd     | 提交日期                                   |
| %cr     | 提交日期，按多久以前的方式显示             |
| %s      | 提交说明                                   |
| %Creset | 表示重置颜色，不受之前的颜色               |
| %Cred   | 红色                                       |
| %Cgreen | 绿色                                       |
| %Cblue  | 蓝色                                       |

 作者（author）和 提交者（committer）区别 : 作者指的是实际作出修改的人，提交者指的是最后将此修改提交到仓库的人

### 命令别名

自定义的命令无疑是很长的，基本上只能复制粘贴地进行使用，所以使用命令别名来更方便地使用

如以下命令设置别名为git lg ，之后直接输入git lg即可

```sh
git config --global alias.lg "log --pretty=format:'* %Cblue%h%Creset - (%Cgreen%ar%Creset) %s -- %Cblue%an'"
```

## 查看与删除代理

```sh
# 查看全局http代理
git config --global http.proxy
# 查看全局https代理
git config --global https.proxy
# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
```

## shell脚本一键提交代码

在本地项目文件夹目录中，新建txt文件，加入以下内容，更改后缀为bat，点击即可运行，会将当前项目直接提交

```sh
#! /bin/bash
time=$(date "+%Y-%m-%d %H:%M:%S")
git add .
git commit -m ":memo:撰写文档 $time"
git push
```

##  Fast-forward

默认情况下直接使用 `git merge` 命令，没有附加任何选项命令的话，那么应该是交给 git 来判断使用哪种 merge 模式，实际上 git 默认执行的指令是 `git merge -ff` 指令（默认值）

### 什么是 `Fast-forward`

git merge会自动执行了 `Fast-forward` 操作
`Fast-forward` 是指 Master 合并 Feature 时候发现 Master 当前节点一直和 Feature 的根节点相同，没有发生改变，那么 Master 快速移动头指针到 Feature 的位置，所以 **Fast-forward 并不会发生真正的合并**，只是通过移动指针造成合并的假象，这也体现 git 设计的巧妙之处。

先简单介绍一下 `git merge` 的三个合并参数模式：

- -ff 自动合并模式：当合并的分支为当前分支的后代的，那么会自动执行 `--ff (Fast-forward)` 模式，如果不匹配则执行 `--no-ff（non-Fast-forward）` 合并模式
- --no-ff 非 Fast-forward 模式：在任何情况下都会创建新的 commit 进行多方合并（及时被合并的分支为自己的直接后代）
- --ff-onlu Fast-forward 模式：只会按照 `Fast-forward` 模式进行合并，如果不符合条件（并非当前分支的直接后代），则会拒绝合并请求并且推出

### 选择

三种 merge 模式没有好坏和优劣之分，只有根据团队的需求和实际情况选择合适的合并模式才是最优解，那么应该怎么选择呢？ 给出以下推荐：

- 如果你是小型团队，并且追求干净线性 git 历史记录，那么我推荐使用 `git merge --ff-only` 方式保持主线模式开发是一种不错的选择
- 如果你团队不大不小，并且也不追求线性的 git 历史记录，要体现相对真实的 merge 记录，那么默认的 `git --ff` 比较合适
- 如果你是大型团队，并且要严格监控每个功能分支的合并情况，那么使用 `--no-ff` 禁用 `Fast-forward` 是一个不错的选择

# 
