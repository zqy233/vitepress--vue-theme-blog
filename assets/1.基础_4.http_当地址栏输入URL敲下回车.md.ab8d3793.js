import{_ as e,o as l,c as i,a}from"./app.bfa9bd4b.js";const f=JSON.parse('{"title":"地址栏输入 URL 敲下回车后发生了什么","description":"","frontmatter":{},"headers":[{"level":2,"title":"简单分析","slug":"简单分析","link":"#简单分析","children":[]},{"level":2,"title":"详细分析","slug":"详细分析","link":"#详细分析","children":[{"level":3,"title":"URL解析","slug":"url解析","link":"#url解析","children":[]},{"level":3,"title":"DNS查询","slug":"dns查询","link":"#dns查询","children":[]},{"level":3,"title":"TCP连接","slug":"tcp连接","link":"#tcp连接","children":[]},{"level":3,"title":"发送 http 请求","slug":"发送-http-请求","link":"#发送-http-请求","children":[]},{"level":3,"title":"响应请求","slug":"响应请求","link":"#响应请求","children":[]},{"level":3,"title":"[页面渲染","slug":"页面渲染","link":"#页面渲染","children":[]}]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"relativePath":"1.基础/4.http/当地址栏输入URL敲下回车.md","lastUpdated":1720835436686}'),t={name:"1.基础/4.http/当地址栏输入URL敲下回车.md"},r=a('<h1 id="地址栏输入-url-敲下回车后发生了什么" tabindex="-1">地址栏输入 URL 敲下回车后发生了什么 <a class="header-anchor" href="#地址栏输入-url-敲下回车后发生了什么" aria-hidden="true">#</a></h1><h2 id="简单分析" tabindex="-1">简单分析 <a class="header-anchor" href="#简单分析" aria-hidden="true">#</a></h2><p>简单的分析，从输入 <code>URL</code>到回车后发生的行为如下：</p><ul><li>URL解析</li><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ul><h2 id="详细分析" tabindex="-1">详细分析 <a class="header-anchor" href="#详细分析" aria-hidden="true">#</a></h2><h3 id="url解析" tabindex="-1">URL解析 <a class="header-anchor" href="#url解析" aria-hidden="true">#</a></h3><p>首先判断你输入的是一个合法的<code>URL</code> 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p><h3 id="dns查询" tabindex="-1">DNS查询 <a class="header-anchor" href="#dns查询" aria-hidden="true">#</a></h3><p>获取域名对应的目标服务器<code>IP</code>地址</p><h3 id="tcp连接" tabindex="-1">TCP连接 <a class="header-anchor" href="#tcp连接" aria-hidden="true">#</a></h3><p>在之前文章中，了解到<code>tcp</code>是一种面向有连接的传输层协议</p><p>在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接</p><h3 id="发送-http-请求" tabindex="-1">发送 http 请求 <a class="header-anchor" href="#发送-http-请求" aria-hidden="true">#</a></h3><p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>请求的内容包括：</p><ul><li>请求行</li><li>请求头</li><li>请求主体</li></ul><h3 id="响应请求" tabindex="-1">响应请求 <a class="header-anchor" href="#响应请求" aria-hidden="true">#</a></h3><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p><h3 id="页面渲染" tabindex="-1">[页面渲染 <a class="header-anchor" href="#页面渲染" aria-hidden="true">#</a></h3><p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</p><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等</li><li>查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式</li></ul><p>关于页面的渲染过程如下：</p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><h2 id="参考文献" tabindex="-1">参考文献 <a class="header-anchor" href="#参考文献" aria-hidden="true">#</a></h2><ul><li><a href="https://github.com/febobo/web-interview/issues/141" target="_blank" rel="noreferrer">https://github.com/febobo/web-interview/issues/141</a></li><li><a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/80551769</a></li></ul>',27),d=[r];function h(n,c,o,s,p,u){return l(),i("div",null,d)}const b=e(t,[["render",h]]);export{f as __pageData,b as default};
