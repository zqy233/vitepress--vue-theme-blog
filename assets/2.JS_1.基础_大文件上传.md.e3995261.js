import{_ as s,o as a,c as n,a as e}from"./app.bfa9bd4b.js";const h=JSON.parse('{"title":"大文件上传","description":"","frontmatter":{},"headers":[{"level":2,"title":"需求分析","slug":"需求分析","link":"#需求分析","children":[]},{"level":2,"title":"什么是 web worker","slug":"什么是-web-worker","link":"#什么是-web-worker","children":[]},{"level":2,"title":"进度条功能","slug":"进度条功能","link":"#进度条功能","children":[]},{"level":2,"title":"文件秒传","slug":"文件秒传","link":"#文件秒传","children":[]},{"level":2,"title":"断点续传","slug":"断点续传","link":"#断点续传","children":[]},{"level":2,"title":"文件切片","slug":"文件切片","link":"#文件切片","children":[]},{"level":2,"title":"暂停上传","slug":"暂停上传","link":"#暂停上传","children":[]}],"relativePath":"2.JS/1.基础/大文件上传.md","lastUpdated":1720835436686}'),l={name:"2.JS/1.基础/大文件上传.md"},p=e(`<h1 id="大文件上传" tabindex="-1">大文件上传 <a class="header-anchor" href="#大文件上传" aria-hidden="true">#</a></h1><blockquote><ul><li>Web Worker 使用教程 <a href="https://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2018/07/web-worker.html</a></li><li>Vite 中使用 WebWorker <a href="https://kuizuo.cn/vite-webworker/" target="_blank" rel="noreferrer">https://kuizuo.cn/vite-webworker/</a></li><li>vue 中使用 web worker <a href="https://www.jianshu.com/p/b00ef894c507" target="_blank" rel="noreferrer">https://www.jianshu.com/p/b00ef894c507</a></li><li>前端超大大文件上传实现以及优化 <a href="https://juejin.cn/post/6986188684605259783#heading-12" target="_blank" rel="noreferrer">https://juejin.cn/post/6986188684605259783#heading-12</a></li></ul></blockquote><h2 id="需求分析" tabindex="-1">需求分析 <a class="header-anchor" href="#需求分析" aria-hidden="true">#</a></h2><p>针对大文件上传，最少做到以下几点</p><ul><li>大文件切割，分片上传</li><li>如果有部分切片上传失败了，我们希望提醒用户重新上传，并且上传成功不需要上传</li><li>最好能有上传的进度提示</li></ul><h2 id="什么是-web-worker" tabindex="-1">什么是 web worker <a class="header-anchor" href="#什么是-web-worker" aria-hidden="true">#</a></h2><blockquote><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p></blockquote><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#C678DD;">var</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">worker</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">Worker</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;work.js&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#B392F0;"> worker </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Worker(</span><span style="color:#FFAB70;">&#39;work.js&#39;</span><span style="color:#B392F0;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>Worker 线程有一些自己的全局属性和方法。</p><blockquote><p><a href="http://self.name" target="_blank" rel="noreferrer">self.name</a>： Worker 的名字。该属性只读，由构造函数指定。 self.onmessage：指定message事件的监听函数。 self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 self.close()：关闭 Worker 线程。 self.postMessage()：向产生这个 Worker 线程发送消息。 self.importScripts()：加载 JS 脚本。</p></blockquote><p>Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。 该方法可以同时加载多个脚本</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">importScripts</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;script1.js&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#61AFEF;">importScripts</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;script1.js&#39;</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;script2.js&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#B392F0;">importScripts(</span><span style="color:#FFAB70;">&#39;script1.js&#39;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">importScripts(</span><span style="color:#FFAB70;">&#39;script1.js&#39;</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&#39;script2.js&#39;</span><span style="color:#B392F0;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="进度条功能" tabindex="-1">进度条功能 <a class="header-anchor" href="#进度条功能" aria-hidden="true">#</a></h2><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度</p><h4 id="切片进度条" tabindex="-1">切片进度条 <a class="header-anchor" href="#切片进度条" aria-hidden="true">#</a></h4><p>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p><p>每一个切片都需要对应一个上传的进度，这个时候应该写一个方法针对切片对象进行进度条的除了，</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// item是我们的chunk对象</span></span>
<span class="line"><span style="color:#61AFEF;">createProgressHandler</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">item</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;font-style:italic;">e</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">item</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">percentage</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">parseInt</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">String</span><span style="color:#ABB2BF;">((</span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">loaded</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">/</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">e</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">total</span><span style="color:#ABB2BF;">) </span><span style="color:#56B6C2;">*</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">));</span></span>
<span class="line"><span style="color:#ABB2BF;">  };</span></span>
<span class="line"><span style="color:#ABB2BF;">},</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#6B737C;">// item是我们的chunk对象</span></span>
<span class="line"><span style="color:#B392F0;">createProgressHandler(item) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> (e) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">item</span><span style="color:#B392F0;">.percentage </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> parseInt(String((</span><span style="color:#79B8FF;">e</span><span style="color:#B392F0;">.loaded </span><span style="color:#F97583;">/</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">e</span><span style="color:#B392F0;">.total) </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">100</span><span style="color:#B392F0;">));</span></span>
<span class="line"><span style="color:#B392F0;">  };</span></span>
<span class="line"><span style="color:#B392F0;">}</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="文件的进度条" tabindex="-1">文件的进度条 <a class="header-anchor" href="#文件的进度条" aria-hidden="true">#</a></h4><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#E06C75;">computed</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">// 针对每一个 chunk的进度 计算出总的上传进度</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#61AFEF;">uploadPercentage</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">file</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">||</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">!</span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">chunkList</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">loaded</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">chunkList</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">map</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;font-style:italic;">item</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">item</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">size</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">*</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">item</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">percentage</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">reduce</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;font-style:italic;">acc</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">cur</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">acc</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">cur</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">parseInt</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;">loaded</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">/</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">file</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">size</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">toFixed</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">));</span></span>
<span class="line"><span style="color:#ABB2BF;">  },</span></span>
<span class="line"><span style="color:#ABB2BF;">},</span></span>
<span class="line"><span style="color:#E06C75;">复制代码</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#B392F0;">computed</span><span style="color:#BBBBBB;">:</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#6B737C;">// 针对每一个 chunk的进度 计算出总的上传进度</span></span>
<span class="line"><span style="color:#B392F0;">  uploadPercentage() {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">if</span><span style="color:#B392F0;"> (</span><span style="color:#F97583;">!</span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.file </span><span style="color:#F97583;">||</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">!</span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">chunkList</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">length</span><span style="color:#B392F0;">) </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">0</span><span style="color:#B392F0;">;</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">const</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">loaded</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">chunkList</span><span style="color:#B392F0;">.map((item) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">item</span><span style="color:#B392F0;">.size </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">item</span><span style="color:#B392F0;">.percentage).reduce((acc</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> cur) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> acc </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> cur);</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#F97583;">return</span><span style="color:#B392F0;"> parseInt((loaded </span><span style="color:#F97583;">/</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">this</span><span style="color:#B392F0;">.</span><span style="color:#79B8FF;">file</span><span style="color:#B392F0;">.size).toFixed(</span><span style="color:#F8F8F8;">2</span><span style="color:#B392F0;">));</span></span>
<span class="line"><span style="color:#B392F0;">  }</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">}</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">复制代码</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>大文件上传的基本功能就差不多完成了。</p><h2 id="文件秒传" tabindex="-1">文件秒传 <a class="header-anchor" href="#文件秒传" aria-hidden="true">#</a></h2><p>这个功能的意思就是说，我们在文件上传之前，去问一下服务器，你有没有这个文件呀，你没有的话我就开始上传，你要是有的话我就偷个懒，用你有的我就不上传了</p><p>所以需要实现一个检测接口(verify)，去询问服务器有没有这个文件，因为我们之前是计算过文件的 hash的，能保证文件的唯一性。就用这个hash就能唯一的判断这个文件。所以这个接口的思路也很简单，就是判断我们的 <code>target</code>目录下是否存在这个文件</p><h2 id="断点续传" tabindex="-1">断点续传 <a class="header-anchor" href="#断点续传" aria-hidden="true">#</a></h2><p>断点续传的意思就是我们上传的时候如果文件上传失败了，我们之后在上传一次的时候，只上传我们之前失败的文件，成功的文件我们就跳过</p><h2 id="文件切片" tabindex="-1">文件切片 <a class="header-anchor" href="#文件切片" aria-hidden="true">#</a></h2><p>选择文件是使用的<code>input</code>输入框，获取到选择的值也很简单。文件切片的核心就是文件对象的<code>slice</code> 方法，类似数组，我们可以调用这个方法获取到文件的某一段</p><h4 id="文件唯一值" tabindex="-1">文件唯一值 <a class="header-anchor" href="#文件唯一值" aria-hidden="true">#</a></h4><p>如何告诉后端，上传的两个文件是不是同一个文件，显然，如果使用文件名作为唯一标识肯定不太好。这个时候我们想到可以使用<code>md5</code>对文件加密获取唯一的<code>hash</code>值</p><p>生成hash值的方法我们是调用 <code>spark-md5</code> 这个库，在计算<code>hash</code>的时候是非常消耗计算机的<code>CPU</code>的会造成浏览器的卡顿，为了优化体验我们使用 <code>web-worker</code> 在 <code>worker</code> 线程计算 <code>hash</code></p><p>在 <code>worker</code> 线程中，接受文件切片 <code>fileChunkList</code>，利用 <code>FileReader</code> 读取每个切片的 <code>ArrayBuffer</code> 并不断传入 <code>spark-md5</code> 中，每计算完一个切片通过 <code>postMessage</code> 向主线程发送一个进度事件，全部完成后将最终的 <code>hash</code> 发送给主线程</p><h2 id="暂停上传" tabindex="-1">暂停上传 <a class="header-anchor" href="#暂停上传" aria-hidden="true">#</a></h2><p>我们先自己手动实现一个按钮，点击之后就停止当前的上传情况。模拟了上传失败</p><p>这个思路肯定就是要改装我们的 <code>request</code>方法，在改装之前我们需要知道 <code>XMLHttpRequest</code>对象是可以自己主动停止当前的网络连接的，不知道的同学<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest" target="_blank" rel="noreferrer">补补课</a>。</p><p>这样我们只需要使用一个公共的数组，每一次发请求的时候都保存我们当前的这个<code>XMLHttpRequest</code>对象，当请求成功之后，我们就移除这个对象，当点击暂停按钮的时候我们就遍历这个数组调用每一个<code>XMLHttpRequest</code>的<code>abrot</code>方法就可以取消上传了。</p>`,38),o=[p];function r(t,c,B,i,y,F){return a(),n("div",null,o)}const u=s(l,[["render",r]]);export{h as __pageData,u as default};
