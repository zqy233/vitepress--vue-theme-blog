import{_ as s,o as n,c as o,a}from"./app.bfa9bd4b.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"一、Hooks 组件","slug":"一、hooks-组件","link":"#一、hooks-组件","children":[]},{"level":2,"title":"对应表格","slug":"对应表格","link":"#对应表格","children":[]},{"level":2,"title":"多个组件的执行顺序","slug":"多个组件的执行顺序","link":"#多个组件的执行顺序","children":[{"level":3,"title":"1. 父子组件","slug":"_1-父子组件","link":"#_1-父子组件","children":[]}]}],"relativePath":"3.框架/10.react/4.hooks.md","lastUpdated":1720835436694}'),e={name:"3.框架/10.react/4.hooks.md"},t=a(`<p>React 生命周期很多人都了解，但通常我们所了解的都是 <strong>单个组件</strong> 的生命周期，但针对 <strong>Hooks 组件、多个关联组件</strong>（父子组件和兄弟组件） 的生命周期又是怎么样的喃？你有思考和了解过吗，接下来我们将完整的了解 React 生命周期。</p><p>关于 <strong>组件</strong> ，我们这里指的是 <code>React.Component</code> 以及 <code>React.PureComponent</code> ，但是否包括 Hooks 组件喃？</p><h3 id="一、hooks-组件" tabindex="-1">一、Hooks 组件 <a class="header-anchor" href="#一、hooks-组件" aria-hidden="true">#</a></h3><p><strong>函数组件</strong> 的本质是函数，没有 state 的概念的，因此<strong>不存在生命周期</strong>一说，仅仅是一个 <strong>render 函数</strong>而已。</p><p>但是引入 <strong>Hooks</strong> 之后就变得不同了，它能让组件在不使用 class 的情况下使用 state 以及其他的 React特性，相比与 class 的生命周期概念来说，它更接近于实现状态同步，而不是响应生命周期事件。但我们可以利用 <code>useState</code>、 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 来模拟实现生命周期</p><p>即：<strong>Hooks 组件更接近于实现状态同步，而不是响应生命周期事件</strong></p><p>下面，是具体的 生命周期 与 Hooks 的<strong>对应关系</strong>：</p><p><code>constructor</code>：函数组件不需要构造函数，我们可以通过调用 <strong><code>useState</code> 来初始化 state</strong>。如果计算的代价比较昂贵，也可以传一个函数给 <code>useState</code>。</p><div class="language-scss line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">const [num, UpdateNum] = useState(0)</span></span>
<span class="line"><span style="color:#ABB2BF;">复制代码</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#B392F0;">const [num, UpdateNum] = useState(0)</span></span>
<span class="line"><span style="color:#B392F0;">复制代码</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>getDerivedStateFromProps</code>：一般情况下，我们不需要使用它，我们可以在<strong>渲染过程中更新 state</strong>，以达到实现 <code>getDerivedStateFromProps</code> 的目的。</p><div class="language-scss line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">scss</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">function ScrollView({row}) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  let [isScrollingDown, setIsScrollingDown] = useState(false);</span></span>
<span class="line"><span style="color:#ABB2BF;">  let [prevRow, setPrevRow] = useState(null);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  if (row !== prevRow) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span></span>
<span class="line"><span style="color:#ABB2BF;">    setIsScrollingDown(prevRow !== null </span><span style="color:#E06C75;">&amp;&amp;</span><span style="color:#ABB2BF;"> row &gt; prevRow);</span></span>
<span class="line"><span style="color:#ABB2BF;">    setPrevRow(row);</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">  return \`Scrolling down: \${isScrollingDown}\`;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#B392F0;">function ScrollView({</span><span style="color:#79B8FF;">row</span><span style="color:#B392F0;">}) {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">let</span><span style="color:#B392F0;"> [</span><span style="color:#79B8FF;">is</span><span style="color:#B392F0;">S</span><span style="color:#79B8FF;">crolling</span><span style="color:#B392F0;">D</span><span style="color:#79B8FF;">own</span><span style="color:#B392F0;">, </span><span style="color:#79B8FF;">set</span><span style="color:#B392F0;">I</span><span style="color:#79B8FF;">s</span><span style="color:#B392F0;">S</span><span style="color:#79B8FF;">crolling</span><span style="color:#B392F0;">D</span><span style="color:#79B8FF;">own</span><span style="color:#B392F0;">] = </span><span style="color:#79B8FF;">use</span><span style="color:#B392F0;">S</span><span style="color:#79B8FF;">tate</span><span style="color:#B392F0;">(</span><span style="color:#79B8FF;">false</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">let</span><span style="color:#B392F0;"> [</span><span style="color:#79B8FF;">prev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;">, </span><span style="color:#79B8FF;">set</span><span style="color:#B392F0;">P</span><span style="color:#79B8FF;">rev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;">] = </span><span style="color:#79B8FF;">use</span><span style="color:#B392F0;">S</span><span style="color:#79B8FF;">tate</span><span style="color:#B392F0;">(</span><span style="color:#79B8FF;">null</span><span style="color:#B392F0;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">if</span><span style="color:#B392F0;"> (</span><span style="color:#79B8FF;">row</span><span style="color:#B392F0;"> !== </span><span style="color:#79B8FF;">prev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;">) {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">set</span><span style="color:#B392F0;">I</span><span style="color:#79B8FF;">s</span><span style="color:#B392F0;">S</span><span style="color:#79B8FF;">crolling</span><span style="color:#B392F0;">D</span><span style="color:#79B8FF;">own</span><span style="color:#B392F0;">(</span><span style="color:#79B8FF;">prev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;"> !== </span><span style="color:#79B8FF;">null</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&amp;&amp;</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">row</span><span style="color:#B392F0;"> &gt; </span><span style="color:#79B8FF;">prev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#79B8FF;">set</span><span style="color:#B392F0;">P</span><span style="color:#79B8FF;">rev</span><span style="color:#B392F0;">R</span><span style="color:#79B8FF;">ow</span><span style="color:#B392F0;">(</span><span style="color:#79B8FF;">row</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#B392F0;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">return</span><span style="color:#B392F0;"> \`S</span><span style="color:#79B8FF;">crolling</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">down</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">\${isScrollingDown</span><span style="color:#B392F0;">}\`;</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="对应表格" tabindex="-1">对应表格 <a class="header-anchor" href="#对应表格" aria-hidden="true">#</a></h2><p>为方便记忆，大致汇总成表格如下。</p><table><thead><tr><th>class 组件</th><th>Hooks 组件</th></tr></thead><tbody><tr><td>constructor</td><td>useState</td></tr><tr><td>getDerivedStateFromProps</td><td>useState 里面 update 函数</td></tr><tr><td>shouldComponentUpdate</td><td>useMemo</td></tr><tr><td>render</td><td>函数本身</td></tr><tr><td>componentDidMount</td><td>useEffect</td></tr><tr><td>componentDidUpdate</td><td>useEffect</td></tr><tr><td>componentWillUnmount</td><td>useEffect 里面返回的函数</td></tr><tr><td>componentDidCatch</td><td>无</td></tr><tr><td>getDerivedStateFromError</td><td>无</td></tr></tbody></table><h2 id="多个组件的执行顺序" tabindex="-1">多个组件的执行顺序 <a class="header-anchor" href="#多个组件的执行顺序" aria-hidden="true">#</a></h2><h3 id="_1-父子组件" tabindex="-1">1. 父子组件 <a class="header-anchor" href="#_1-父子组件" aria-hidden="true">#</a></h3><ul><li><p><strong>挂载阶段</strong></p><p>分 <strong>两个</strong> 阶段：</p><ul><li>第 <strong>一</strong> 阶段，由父组件开始执行到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对其中 <strong>同步的子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并 commit 到 DOM。</li><li>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code>componentDidMount</code>，最后触发父组件的。</li></ul><p><strong>注意</strong>：如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p><p>所以执行顺序是：</p><p>父组件 getDerivedStateFromProps —&gt; 同步子组件 getDerivedStateFromProps —&gt; 同步子组件 componentDidMount —&gt; 父组件 componentDidMount —&gt; 异步子组件 getDerivedStateFromProps —&gt; 异步子组件 componentDidMount</p></li><li><p><strong>更新阶段</strong></p><p><strong>React 的设计遵循单向数据流模型</strong> ，也就是说，数据均是由父组件流向子组件。</p><ul><li><p>第 <strong>一</strong> 阶段，由父组件开始，执行</p><ol><li><code>static getDerivedStateFromProps</code></li><li><code>shouldComponentUpdate</code></li></ol><p>更新到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对 <strong>子组件</strong> 进行创建，按 <strong>递归顺序</strong> 挨个执行各个子组件至 <code>render</code>，生成到父子组件对应的 Virtual DOM 树，并与已有的 Virtual DOM 树 比较，计算出 <strong>Virtual DOM 真正变化的部分</strong> ，并只针对该部分进行的原生DOM操作。</p></li><li><p>第 <strong>二</strong> 阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件以下函数，最后触发父组件的。</p><ol><li><code>getSnapshotBeforeUpdate()</code></li><li><code>componentDidUpdate()</code></li></ol><p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。</p><p>所以执行顺序是：</p><p>父组件 getDerivedStateFromProps —&gt; 父组件 shouldComponentUpdate —&gt; 子组件 getDerivedStateFromProps —&gt; 子组件 shouldComponentUpdate —&gt; 子组件 getSnapshotBeforeUpdate —&gt; 父组件 getSnapshotBeforeUpdate —&gt; 子组件 componentDidUpdate —&gt; 父组件 componentDidUpdate</p></li></ul></li><li><p><strong>卸载阶段</strong></p><p><code>componentWillUnmount()</code>，顺序为 <strong>父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法</strong>。</p><p><strong>注意</strong> ：如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code>render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p></li></ul><h4 id="_2-兄弟组件" tabindex="-1">2. 兄弟组件 <a class="header-anchor" href="#_2-兄弟组件" aria-hidden="true">#</a></h4><ul><li><p><strong>挂载阶段</strong></p><p>若是同步路由，它们的创建顺序和其在共同父组件中定义的先后顺序是 <strong>一致</strong> 的。</p><p>若是异步路由，它们的创建顺序和 js 加载完成的顺序一致。</p></li><li><p><strong>更新阶段、卸载阶段</strong></p><p>兄弟节点之间的通信主要是经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code>props</code> 实现的），<strong>满足React 的设计遵循单向数据流模型</strong>， <strong>因此任何两个组件之间的通信，本质上都可以归结为父子组件更新的情况</strong> 。</p><p>所以，兄弟组件更新、卸载阶段，请参考 <strong>父子组件</strong>。</p><h2 id="effect-进行性能优化" tabindex="-1">Effect 进行性能优化 <a class="header-anchor" href="#effect-进行性能优化" aria-hidden="true">#</a></h2></li></ul>`,19),l=[t];function p(r,c,d,i,F,B){return n(),o("div",null,l)}const u=s(e,[["render",p]]);export{g as __pageData,u as default};
