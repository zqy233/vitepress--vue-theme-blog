import{_ as s,o as n,c as e,a}from"./app.bfa9bd4b.js";const F=JSON.parse('{"title":"Intersection Observer API","description":"","frontmatter":{},"headers":[{"level":2,"title":"Intersection observer 的概念和用法","slug":"intersection-observer-的概念和用法","link":"#intersection-observer-的概念和用法","children":[{"level":3,"title":"创建一个 intersection observer","slug":"创建一个-intersection-observer","link":"#创建一个-intersection-observer","children":[]},{"level":3,"title":"Intersection observer options","slug":"intersection-observer-options","link":"#intersection-observer-options","children":[]},{"level":3,"title":"Targeting an element to be observed","slug":"targeting-an-element-to-be-observed","link":"#targeting-an-element-to-be-observed","children":[]}]}],"relativePath":"2.JS/5.api/IntersectionObserver.md","lastUpdated":1720835436690}'),o={name:"2.JS/5.api/IntersectionObserver.md"},l=a(`<h1 id="intersection-observer-api" tabindex="-1">Intersection Observer API <a class="header-anchor" href="#intersection-observer-api" aria-hidden="true">#</a></h1><p>Intersection Observer API 提供了一种异步检测目标元素与祖先元素或 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport" target="_blank" rel="noreferrer">viewport</a> 相交情况变化的方法。</p><p>过去，要检测一个元素是否可见或者两个元素是否相交并不容易，很多解决办法不可靠或性能很差。然而，随着互联网的发展，这种需求却与日俱增，比如，下面这些情况都需要用到相交检测：</p><ul><li>图片懒加载——当图片滚动到可见时才进行加载</li><li>内容无限滚动——也就是用户滚动到接近内容底部时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li><li>检测广告的曝光情况——为了计算广告收益，需要知道广告元素的曝光情况</li><li>在用户看见某个区域时执行任务或播放动画</li></ul><p>过去，相交检测通常要用到事件监听，并且需要频繁调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noreferrer"><code>Element.getBoundingClientRect()</code></a> 方法以获取相关元素的边界信息。事件监听和调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noreferrer"><code>Element.getBoundingClientRect()</code></a> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。这种检测方法极其怪异且不优雅。</p><p>假如有一个无限滚动的网页，开发者使用了一个第三方库来管理整个页面的广告，又用了另外一个库来实现消息盒子和点赞，并且页面有很多动画（译注：动画往往意味着较高的性能消耗）。两个库都有自己的相交检测程序，都运行在主线程里，而网站的开发者对这些库的内部实现知之甚少，所以并未意识到有什么问题。但当用户滚动页面时，这些相交检测程序就会在页面滚动回调函数里不停触发调用，造成性能问题，体验效果让人失望。</p><p>Intersection Observer API 会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时 (或者 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport" target="_blank" rel="noreferrer">viewport</a> )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。</p><p>注意 Intersection Observer API 无法提供重叠的像素个数或者具体哪个像素重叠，他的更常见的使用方式是——当两个元素相交比例在 N% 左右时，触发回调，以执行某些逻辑。</p><h2 id="intersection-observer-的概念和用法" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API#intersection_observer_%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95" target="_blank" rel="noreferrer">Intersection observer 的概念和用法</a> <a class="header-anchor" href="#intersection-observer-的概念和用法" aria-hidden="true">#</a></h2><p>Intersection Observer API 允许你配置一个回调函数，当以下情况发生时会被调用</p><ul><li>每当目标 (<strong>target</strong>) 元素与设备视窗或者其他指定元素发生交集的时候执行。设备视窗或者其他元素我们称它为根元素或根 (<strong>root</strong>)。</li><li>Observer 第一次监听目标元素的时候</li></ul><p>通常，您需要关注文档最接近的可滚动祖先元素的交集更改，如果元素不是可滚动元素的后代，则默认为设备视窗。如果要观察相对于根 (<strong>root</strong>) 元素的交集，请指定根 (<strong>root</strong>) 元素为<code>null</code>。</p><p>无论您是使用视口还是其他元素作为根，API 都以相同的方式工作，只要目标元素的可见性发生变化，就会执行您提供的回调函数，以便它与所需的交叉点交叉。</p><p>目标 (<strong>target</strong>) 元素与根 (<strong>root</strong>) 元素之间的交叉度是交叉比 (<strong>intersection ratio</strong>)。这是目标 (<strong>target</strong>) 元素相对于根 (<strong>root</strong>) 的交集百分比的表示，它的取值在 0.0 和 1.0 之间。</p><h3 id="创建一个-intersection-observer" tabindex="-1"><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA_intersection_observer" target="_blank" rel="noreferrer">创建一个 intersection observer</a> <a class="header-anchor" href="#创建一个-intersection-observer" aria-hidden="true">#</a></h3><p>创建一个 IntersectionObserver 对象，并传入相应参数和回调用函数，该回调函数将会在目标 (<strong>target</strong>) 元素和根 (<strong>root</strong>) 元素的交集大小超过阈值 (<strong>threshold</strong>) 规定的大小时候被执行。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">options</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">root</span><span style="color:#ABB2BF;">: </span><span style="color:#E5C07B;">document</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">querySelector</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;#scrollArea&#39;</span><span style="color:#ABB2BF;">),</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">rootMargin</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;0px&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E06C75;">threshold</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">1.0</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">observer</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">new</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">IntersectionObserver</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">callback</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">options</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> options </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  root</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">document</span><span style="color:#B392F0;">.querySelector(</span><span style="color:#FFAB70;">&#39;#scrollArea&#39;</span><span style="color:#B392F0;">)</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  rootMargin</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#FFAB70;">&#39;0px&#39;</span><span style="color:#BBBBBB;">,</span></span>
<span class="line"><span style="color:#B392F0;">  threshold</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> </span><span style="color:#F8F8F8;">1.0</span></span>
<span class="line"><span style="color:#B392F0;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> observer </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> IntersectionObserver(callback</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> options);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>阈值为 1.0 意味着目标元素完全出现在 root 选项指定的元素中可见时，回调函数将会被执行。</p><h3 id="intersection-observer-options" tabindex="-1">Intersection observer options <a class="header-anchor" href="#intersection-observer-options" aria-hidden="true">#</a></h3><p>传递到 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/IntersectionObserver" target="_blank" rel="noreferrer"><code>IntersectionObserver()</code></a> 构造函数的 <code>options</code> 对象，允许您控制观察者的回调函数的被调用时的环境。它有以下字段：</p><ul><li><p><code>root</code></p><p>指定根 (<strong>root</strong>) 元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为<code>null</code>，则默认为浏览器视窗。</p></li><li><p><code>rootMargin</code></p><p>根 (<strong>root</strong>) 元素的外边距。类似于 CSS 中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin" target="_blank" rel="noreferrer"><code>margin</code></a> 属性，比如 &quot;<code>10px 20px 30px 40px&quot;</code> (top、right、bottom、left)。如果有指定 root 参数，则 rootMargin 也可以使用百分比来取值。该属性值是用作 root 元素和 target 发生交集时候的计算交集的区域范围，使用该属性可以控制 root 元素每一边的收缩或者扩张。默认值为四个边距全是 0。</p></li><li><p><code>threshold</code></p><p>可以是单一的 number 也可以是 number 数组，target 元素和 root 元素相交程度达到该值的时候 IntersectionObserver 注册的回调函数将会被执行。如果你只是想要探测当 target 元素的在 root 元素中的可见性超过 50% 的时候，你可以指定该属性值为 0.5。如果你想要 target 元素在 root 元素的可见程度每多 25% 就执行一次回调，那么你可以指定一个数组 <code>[0, 0.25, 0.5, 0.75, 1]</code>。默认值是 0 (意味着只要有一个 target 像素出现在 root 元素中，回调函数将会被执行)。该值为 1.0 含义是当 target 完全出现在 root 元素中时候 回调才会被执行。</p></li></ul><h3 id="targeting-an-element-to-be-observed" tabindex="-1">Targeting an element to be observed <a class="header-anchor" href="#targeting-an-element-to-be-observed" aria-hidden="true">#</a></h3><p>创建一个 observer 后需要给定一个目标元素进行观察。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;">target</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">document</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">querySelector</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;#listItem&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">observer</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">observe</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">target</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> target </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> </span><span style="color:#79B8FF;">document</span><span style="color:#B392F0;">.querySelector(</span><span style="color:#FFAB70;">&#39;#listItem&#39;</span><span style="color:#B392F0;">);</span></span>
<span class="line"><span style="color:#79B8FF;">observer</span><span style="color:#B392F0;">.observe(target);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>每当目标满足该 IntersectionObserver 指定的 threshold 值，回调被调用。</p><p>只要目标满足为 IntersectionObserver 指定的阈值，就会调用回调。回调接收 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry" target="_blank" rel="noreferrer"><code>IntersectionObserverEntry</code></a> 对象和观察者的列表：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code-dark" tabindex="0"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">callback</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">entries</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">observer</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#E5C07B;">entries</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">forEach</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">entry</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// Each entry describes an intersection change for one observed target element:</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.boundingClientRect</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.intersectionRatio</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.intersectionRect</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.isIntersecting</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.rootBounds</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.target</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">// entry.time</span></span>
<span class="line"><span style="color:#ABB2BF;">  });</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><pre class="shiki min-dark vp-code-light" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#B392F0;"> callback </span><span style="color:#F97583;">=</span><span style="color:#B392F0;">(entries</span><span style="color:#BBBBBB;">,</span><span style="color:#B392F0;"> observer) </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  </span><span style="color:#79B8FF;">entries</span><span style="color:#B392F0;">.forEach(entry </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> {</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// Each entry describes an intersection change for one observed target element:</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.boundingClientRect</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.intersectionRatio</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.intersectionRect</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.isIntersecting</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.rootBounds</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.target</span></span>
<span class="line"><span style="color:#B392F0;">    </span><span style="color:#6B737C;">// entry.time</span></span>
<span class="line"><span style="color:#B392F0;">  });</span></span>
<span class="line"><span style="color:#B392F0;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div>`,27),r=[l];function t(p,c,i,B,y,d){return n(),e("div",null,r)}const g=s(o,[["render",t]]);export{F as __pageData,g as default};
