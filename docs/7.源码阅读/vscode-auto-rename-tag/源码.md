## vscode语言服务器

[以下内容翻译自vscode官方文档：](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide)

语言服务器是一种特殊的 Visual Studio Code 扩展，可为许多编程语言提供编辑体验。 使用语言服务器，您可以实现自动完成、错误检查（诊断）、跳转到定义以及 VS Code 支持的许多其他语言功能。 

然而，在 VS Code 中实现对语言功能的支持时，我们发现了三个常见问题：

首先，语言服务器通常以其本机编程语言实现，这给将它们与具有 Node.js 运行时的 VS Code 集成带来了挑战 。 

此外，语言功能可能是资源密集型的。 例如，为了正确验证文件，语言服务器需要解析大量文件，为它们建立抽象语法树并执行静态程序分析。 这些操作可能会导致大量的 CPU 和内存使用，我们需要确保 VS Code 的性能不受影响。 

最后，将多种语言工具与多个代码编辑器集成可能需要付出巨大的努力。 从语言工具的角度来看，它们需要适应具有不同API的代码编辑器。 从代码编辑者的角度来看，他们不能期望语言工具提供任何统一的 API。 这使得在 N 个代码编辑器中实现对 M 种语言的语言支持成为 M * N 的工作。

为了解决这些问题，Microsoft 指定了语言服务器协议 [Language Server Protocol](https://microsoft.github.io/language-server-protocol), 该协议标准化了语言工具和代码编辑器之间的通信。 这样，语言服务器可以用任何语言实现并在自己的进程中运行，以避免性能成本，因为它们通过语言服务器协议与代码编辑器进行通信。 此外，任何符合 LSP 的语言工具都可以与多个符合 LSP 的代码编辑器集成，并且任何符合 LSP 的代码编辑器都可以轻松选择多个符合 LSP 的语言工具。 LSP 对于语言工具提供商和代码编辑器供应商来说都是双赢！

### 实现语言服务器

在 VS Code 中，语言服务器有两部分：

语言客户端：用 JavaScript / TypeScript 编写的普通 VS Code 扩展。 此扩展可以访问所有 VS Code 命名空间 API。
语言服务器：在单独进程中运行的语言分析工具。

如上所述，在单独的进程中运行语言服务器有两个好处：

该分析工具可以用任何语言实现，只要它能够按照语言服务器协议与语言客户端进行通信即可。
由于语言分析工具通常会占用大量 CPU 和内存，因此在单独的进程中运行它们可以避免性能成本。
例如，HTML 语言客户端和 PHP 语言客户端是用 TypeScript 编写的普通 VS Code 扩展。 它们各自实例化一个对应的Language Server，并通过LSP与其进行通信。 尽管PHP语言服务器是用PHP编写的，但它仍然可以通过LSP与PHP语言客户端进行通信。

## serverMain.ts：创建与vscode客户端的连接

```ts
import { TextDocument } from 'vscode-languageserver-textdocument';
import {
  createConnection,
  TextDocuments,
  TextDocumentSyncKind
} from 'vscode-languageserver/node';
import { autoRenameTag, autoRenameTagRequestType } from './autoRenameTag';
import {
  enableBetterErrorHandlingAndLogging,
  handleError
} from './errorHandlingAndLogging';

const connection = createConnection();
const documents = new TextDocuments(TextDocument);

enableBetterErrorHandlingAndLogging(connection);

connection.onInitialize(() => ({
  capabilities: {
    textDocumentSync: TextDocumentSyncKind.Incremental
  }
}));

connection.onInitialized(() => {
  console.log('Auto Rename Tag has been initialized.');
});

const handleRequest: <Params, Result>(
  fn: (params: Params) => Result
) => (params: Params) => Result = fn => params => {
  try {
    return fn(params);
  } catch (error) {
    handleError(error);
    throw error;
  }
};

connection.onRequest(
  autoRenameTagRequestType,
  handleRequest(autoRenameTag(documents))
);

documents.listen(connection);
connection.listen();
```

使用`vscode-languageserver-textdocument`模块进行文本文档的访问和操作。下面是对代码的解释：

1. 导入模块：
```javascript
import { TextDocument } from "vscode-languageserver-textdocument";
import { createConnection, TextDocuments, TextDocumentSyncKind } from "vscode-languageserver/node";
import { autoRenameTag, autoRenameTagRequestType } from "./autoRenameTag";
import { enableBetterErrorHandlingAndLogging, handleError } from "./errorHandlingAndLogging";
```
首先，代码导入了所需的模块。`vscode-languageserver-textdocument`模块用于访问和操作文本文档，`createConnection`和`TextDocuments`模块用于创建与客户端的连接和管理文本文档集合。另外，代码还导入了自定义的`autoRenameTag`和错误处理相关的模块。

2. 创建连接和文档集合：
```javascript
const connection = createConnection();
const documents = new TextDocuments(TextDocument);
```
代码创建了与客户端的连接实例，并使用`TextDocuments`类创建了一个`documents`对象，用于管理打开的文本文档。

3. 初始化和事件处理：
```javascript
enableBetterErrorHandlingAndLogging(connection);

connection.onInitialize(() => ({
  capabilities: {
    textDocumentSync: TextDocumentSyncKind.Incremental,
  },
}));

connection.onInitialized(() => {
  console.log("Auto Rename Tag has been initialized.");
});
```
代码注册了一些事件处理程序。`enableBetterErrorHandlingAndLogging`函数用于改善错误处理和日志记录。`onInitialize`事件处理程序在插件初始化时被触发，返回了插件的功能。在这个例子中，只定义了文本文档同步方式为增量同步。`onInitialized`事件处理程序在插件初始化完成后被触发，这里简单地输出一条初始化完成的日志信息。

4. 请求处理和自动重命名标签：
```javascript
const handleRequest: <Params, Result>(
  fn: (params: Params) => Result
) => (params: Params) => Result = (fn) => (params) => {
  try {
    return fn(params);
  } catch (error) {
    handleError(error);
    throw error;
  }
};

connection.onRequest(
  autoRenameTagRequestType,
  handleRequest(autoRenameTag(documents))
);
```
这段代码定义了一个`handleRequest`函数，用于处理请求并捕获可能的错误。然后，使用`onRequest`方法注册了处理自动重命名标签请求的处理程序，当收到该请求时，会调用`autoRenameTag`函数进行处理。

5. 监听文档变化和启动连接：
```javascript
documents.listen(connection);
connection.listen();
```
通过调用`documents.listen`方法，将`documents`对象与连接关联起来，使其能够处理文档的打开、关闭、更改等事件。最后，调用`connection.listen`方法启动连接，使插件能够接收来自客户端的请求并发送响应。

## 插件客户端：请求服务器

```ts
import * as vscode from 'vscode';
import {
  Code2ProtocolConverter,
  LanguageClient,
  LanguageClientOptions,
  RequestType,
  ServerOptions,
  TransportKind
} from 'vscode-languageclient/node';

type VslSendRequest = <P, R, E>(
  type: RequestType<P, R, E>,
  params: P
) => Thenable<R>;

export interface LanguageClientProxy {
  readonly code2ProtocolConverter: Code2ProtocolConverter;
  readonly sendRequest: VslSendRequest;
}

export const createLanguageClientProxy: (
  context: vscode.ExtensionContext,
  id: string,
  name: string,
  clientOptions: LanguageClientOptions
) => Promise<LanguageClientProxy> = async (
  context,
  id,
  name,
  clientOptions
) => {
  const serverModule = context.asAbsolutePath('../server/dist/serverMain.js');
  const serverOptions: ServerOptions = {
    run: { module: serverModule, transport: TransportKind.ipc },
    debug: {
      module: serverModule,
      transport: TransportKind.ipc,
      options: { execArgv: ['--nolazy', '--inspect=6009'] }
    }
  };
  const outputChannel = vscode.window.createOutputChannel(name);
  clientOptions.outputChannel = {
    name: outputChannel.name,
    append() {},
    appendLine(value: string) {
      try {
        const message = JSON.parse(value);
        if (!message.isLSPMessage) {
          outputChannel.appendLine(value);
        }
      } catch (error) {
        if (typeof value !== 'object') {
          outputChannel.appendLine(value);
        }
      }
    },
    replace(value) {
      outputChannel.replace(value);
    },
    clear() {
      outputChannel.clear();
    },
    show() {
      outputChannel.show();
    },
    hide() {
      outputChannel.hide();
    },
    dispose() {
      outputChannel.dispose();
    }
  };

  const languageClient = new LanguageClient(
    id,
    name,
    serverOptions,
    clientOptions
  );

  languageClient.registerProposedFeatures();
  context.subscriptions.push(languageClient.start());
  await languageClient.onReady();
  const languageClientProxy: LanguageClientProxy = {
    code2ProtocolConverter: languageClient.code2ProtocolConverter,
    sendRequest: (type, params) => languageClient.sendRequest(type, params)
  };
  return languageClientProxy;
};
```

## 插件主函数



