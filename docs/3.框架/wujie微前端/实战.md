# wujie框架应用（主子应用都是vite4+vue3）

## 改造

### 主应用中安装wujie的vue3组件

```js
import WujieVue from 'wujie-vue3';
app.use(WujieVue);
```

### 主应用改造

主应用的界面左侧是菜单栏，右侧是菜单的对应页面

#### 主应用原先是采用动态组件的方式渲染右侧对应页面

```js
<component
   v-if="dynamicComponent"
   :is="dynamicComponent"
></component>
```

```js
let modules = import.meta.glob('../dynamicComponent/**/*.vue');
...
computed: {
  /** 动态组件 */
  dynamicComponent() {
    let filename = this.currentNode.routerName;
    ...
    return defineAsyncComponent(
      modules[`../dynamicComponent/${filename}.vue`]
      );
   }
},
```

#### 现在把`component`动态组件替换成wujie框架

不在主界面进行动态组件的渲染，而是拆分至子应用，把相应路径传递给子应用，子应用收到后进行动态组件的渲染，这样就可以自行拆分页面到相应子应用

```js
<WujieVue
   style="height: 100%"
   name="vue3"
   :url="vue3Url"
   :plugins="plugins"
></WujieVue>
```

```js
 /** 点击树节点也就是单个菜单时触发 */
    handleNodeClick(data) {
      ...
      wujieVue.bus.$emit('vue3-router-change', this.currentNode.routerName);
    },
```

### 子应用`mounted`生命周期里渲染监听事件

子应用中再使用动态组件的方式渲染

```js
<component
   v-if="dynamicComponent"
   :is="dynamicComponent"
></component>
```

`mounted`生命周期里渲染监听事件，设置动态组件路径

```js
mounted() {
    window.$wujie?.bus.$on('vue3-router-change', (path) => {
      this.wujie_dynamicComponent = path;
    });
  },
```

```js
let modules = import.meta.glob('../dynamicComponent/**/*.vue');
... 
computed: {
    /** 动态组件 */
    dynamicComponent() {
      if (this.wujie_dynamicComponent) {
        return defineAsyncComponent(
          modules[`../dynamicComponent/${this.wujie_dynamicComponent}.vue`]
        );
      }
    },
```

## 注意点

主子应用共享localstorage，所以不用传token，用户信息到子应用

同样，要注意主子应用的localstorage的key不能重名，也不能随意localstorage.clear

## 尚未完成的改造

- 刷新完页面恢复到首页  （加localstorage保存dynamicComponent传参）

- 查漏补缺，完善dynamicComponent的页面传参

- 添加前端多包运行库，一键启动所有主子应用（现在需要分别启动主应用和子应用）

- 添加生产环境配置，现在还是开发环境的配置

  

